#define DR_WAV_IMPLEMENTATION
#include "dr_wav.h"
#include <string>
#include <vector>
#include <filesystem>
#include <fstream>
namespace fs = std::filesystem;

bool loadWav(const std::string &path, std::vector<float> &buffer, int *outNumChannels, int *outSampleRate) {
	drwav infile;

	if (!drwav_init_file(&infile, path.c_str(), nullptr)) {
		printf("Can't open file %s for reading\n", path.c_str());
		return false;
	}
	if (outNumChannels) *outNumChannels = infile.fmt.channels;
	if (outSampleRate) *outSampleRate = infile.fmt.sampleRate;

	buffer.resize(infile.totalPCMFrameCount * infile.fmt.channels);

	auto totalNumFramesRead = drwav_read_pcm_frames_f32(&infile, infile.totalPCMFrameCount, buffer.data());

	drwav_uninit(&infile);
	return totalNumFramesRead == infile.totalPCMFrameCount;
}

void zapGremlins(std::string &s) {
	if (s.size() > 0) {
		if (s[0] != '_' && !isalpha(s[0])) {
			s = "m" + s;
		}
	}
	for (int i = 0; i < s.size(); i++) {
		if (s[i] == ' ') s[i] = '_';
		if (s[i] == ':') s[i] = '_';
		if (s[i] == '.') s[i] = '_';
		if (s[i] == ',') s[i] = '_';
		if (s[i] == ';') s[i] = '_';
		if (s[i] == '/') s[i] = '_';
		if (s[i] == '-') s[i] = '_';
		if (s[i] == '+') s[i] = '_';
		if (s[i] == '\\') s[i] = '_';
	}
}

enum class Type { Float, Int16, Uint8 };
std::string typeToCType(Type type) {
	switch (type) {
		case Type::Float: return "float";
		case Type::Int16: return "int16_t";
		case Type::Uint8: return "uint8_t";
	}
	return "float";
}

std::vector<float> resample(const std::vector<float> &inp, int nChans, double resampleFactor) {
	if (resampleFactor == 1) return inp;
	std::vector<float> resampled;
	int numFrames		= inp.size() / nChans;
	int targetNumFrames = static_cast<int>(numFrames / resampleFactor);
	resampled.resize(nChans * targetNumFrames);
	// printf("target num frames: %d\n", targetNumFrames);
	for (int i = 0; i < targetNumFrames; i++) {
		double pos = i * resampleFactor;
		int a	   = (int) pos;
		int b	   = a + 1;
		if (b >= inp.size()) b = inp.size() - 1;
		if (a >= inp.size()) a = inp.size() - 1;
		double frac = pos - a;

		for (int c = 0; c < nChans; c++) {
			resampled[i * nChans + c] = inp[a * nChans + c] * (1.0 - frac) + inp[b * nChans + c] * frac;
		}
	}
	return resampled;
}

static std::string byteSizeToString(uint64_t bytes) {
	char buf[256];
	double size			= bytes;
	int i				= 0;
	const char *units[] = {"B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"};
	while (size > 1024) {
		size /= 1024;
		i++;
	}
	snprintf(buf, sizeof(buf), "%.*f%s", i, size, units[i]);
	return buf;
}

bool wav2h(const fs::path &p, std::string &name, std::string &out, double resampleFactor, Type type) {
	std::vector<float> buff;
	int outNumChannels;
	int outSampleRate;

	if (!loadWav(p.string(), buff, &outNumChannels, &outSampleRate)) {
		return false;
	}

	int originalSize = buff.size();
	if (resampleFactor != 1) {
		buff = resample(buff, outNumChannels, resampleFactor);
	}
	name = p.stem().string();
	zapGremlins(name);

	auto sizeBytes = static_cast<int>(buff.size() * sizeof(float));
	printf(
		"/**\n * Sample:     %s\n * Format:     '%s'\n * Channels:   %d\n * Byte size:  %s\n * Samplerate: %.2fHz \n\n * Generated by wav2h\n */\n",
		p.filename().string().c_str(),
		typeToCType(type).c_str(),
		outNumChannels,
		byteSizeToString(sizeBytes).c_str(),
		outSampleRate * buff.size() / (double) originalSize);

	out = "std::vector<" + typeToCType(type) + "> " + name + " = {\n\t";
	for (int i = 0; i < buff.size(); i++) {
		if (i % 4 == 0 && i > 0) {
			out += "\n\t";
		}
		switch (type) {
			case Type::Float: out += std::to_string(buff[i]) + "f, "; break;
			case Type::Int16: out += std::to_string(static_cast<int16_t>(buff[i] * 32767.0f)) + ", "; break;
			case Type::Uint8: out += std::to_string(static_cast<uint8_t>((buff[i] + 1.0f) * 127.0f)) + ", "; break;
		}
	}
	out += "\n};";
	return true;
}

void printUsage(char *appName) {
	printf("\nUsage\n\n\t%s <path> [-f] [-t type] [-r factor]\n\n", appName);
	printf("\t-f \t write files instead of std::out\n\n");
	printf("\t-t \t convert to a type - options are uint8, int16, float (default)\n\n");
	printf("\t-r \t resample factor, eg 1 is no change (default), 2.0 is half the sample rate\n\n");
}

bool writeStringToFile(const std::string &path, const std::string &data) {
	std::ofstream outfile(path, std::ios::out);
	if (outfile.fail()) {
		printf("writeStringToFile() open failed: %s %s\n", strerror(errno), path.c_str());
		return false;
	}
	outfile << data;
	if (outfile.fail()) {
		printf("writeStringToFile() data write failed: %s\n", strerror(errno));
		return false;
	}
	outfile.close();
	if (outfile.fail()) {
		printf("writeStringToFile() close failed: %s\n", strerror(errno));
		return false;
	}
	return true;
}

int main(int argc, char *argv[]) {
	fs::path p;
	bool writeFiles		  = false;
	double resampleFactor = 1.0;

	Type type = Type::Float;

	if (argc >= 2) {
		p = argv[1];
	} else {
		printUsage(argv[0]);
		return 1;
	}

	for (int i = 2; i < argc; i++) {
		std::string opt(argv[i]);
		if (opt == "-f" && i < argc - 1) {
			writeFiles = true;
			p		   = argv[i + 1];

		} else if (opt == "-r" && i < argc - 1) {
			resampleFactor = atof(argv[i + 1]);
			i++;
			if (resampleFactor <= 0) {
				printf("Invalid resample factor %f\n", resampleFactor);
				return 1;
			}
		} else if (opt == "-t" && i < argc - 1) {
			std::string val = argv[i + 1];
			if (val == "float") {
				type = Type::Float;
			} else if (val == "int16") {
				type = Type::Int16;
			} else if (val == "uint8") {
				type = Type::Uint8;
			} else {
				printf("Invalid type %s\n", val.c_str());
				return 1;
			}
			i++;
		} else {
			printUsage(argv[0]);
			return 1;
		}
	}

	if (!fs::exists(p)) {
		printf("No file exists at %s\n", p.string().c_str());
		return 1;
	}

	if (fs::is_regular_file(p)) {
		std::string name;
		std::string out;
		if (!wav2h(p, name, out, resampleFactor, type)) {
			printf("Failed to read %s\n", p.string().c_str());
			return 1;
		}
		if (writeFiles) {
			auto path = p.parent_path() / (name + ".h");
			if (!writeStringToFile(path.string(), out)) {
				printf("Failed to write to %s\n", path.c_str());
				return 1;
			}
			printf("Wrote to %s\n", path.c_str());
		} else {
			printf("%s\n", out.c_str());
		}

	} else if (fs::is_directory(p)) {
		std::vector<std::string> names;
		std::vector<std::string> filenames;

		std::vector<fs::path> samplePaths;

		for (auto &fp: fs::directory_iterator(p)) {
			if (fp.path().extension() == ".wav" || fp.path().extension() == ".WAV") {
				samplePaths.push_back(fp.path());
			}
		}

		std::sort(samplePaths.begin(), samplePaths.end());

		for (auto &fp: samplePaths) {
			std::string name;
			std::string out;
			if (!wav2h(fp, name, out, resampleFactor, type)) {
				printf("Failed to read %s\n", fp.string().c_str());
			}
			filenames.push_back(fp.filename().string());
			names.push_back(name);

			if (writeFiles) {
				auto path = p / (name + ".h");
				if (!writeStringToFile(path.string(), out)) {
					printf("Failed to write to %s\n", path.c_str());
					return 1;
				}
				printf("Wrote to %s\n", path.c_str());
			} else {
				printf("%s\n", out.c_str());
			}
		}

		std::string samplesH;
		if (writeFiles) {
			// do includes
			for (const auto &n: names) {
				samplesH += "#include \"" + n + ".h\"\n";
			}
		}

		samplesH += "\n\nstd::vector<std::vector<" + typeToCType(type) + ">*> samples = {\n";
		for (const auto &n: names) {
			samplesH += "\t&" + n + ",\n";
		}

		samplesH += "};\n\n";

		samplesH += "\n\nstd::vector<std::string> sampleNames = {\n";

		for (const auto &n: filenames) {
			samplesH += "\t\"" + n + "\",\n";
		}

		samplesH += "};\n\n";

		if (writeFiles) {
			auto path = p / "samples.h";
			if (!writeStringToFile(path.string(), samplesH)) {
				printf("Failed to write to %s\n", path.c_str());
				return 1;
			}
			printf("Wrote to %s\n", path.c_str());
		} else {
			printf("%s\n", samplesH.c_str());
		}
	} else {
		printf("Don't know how to deal with that kind of path (%s)\n", p.string().c_str());
		return 1;
	}
	// printf("Wav size: %d\n", buff.size());
	return 0;
}